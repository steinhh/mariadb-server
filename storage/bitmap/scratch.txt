First take at fixing race condition bug due to improper unlocking of engine 
lock, making shares/buckets available prematurely while being created.

Mutex operation functions have names <mutex-name>_lock/_lock_try/
lock_yield. This allows easy grepping for <mutex-name>_lock to 
see all ops on that mutex.

New enum EngineLocked { LOCK_OPEN, LOCK_LOCKED, LOCK_OURS }

Class Bucket now takes two new parameters: EngineLocked
engine_is_locked, and n_bucket_children. Bucket also has functions
bucket_engine_lock [ _yield | _set ], which will inform (recursively)
any (registered!) Bucket children through their
bucket_engine_lock_set() function about changes. The bucket_lock
functions will *not* alter lock status unless it's LOCK_OPEN (when
locking) or LOCK_OURS (when opening). In cases of "bad programming"
(unlocking unlocked lock/locking locked lock) it will complain and
crash!

Both Scalarrbucket and Bitbucket have an extra argument, EngineLocked
engine_locked, to be passed on in the initialization of their Bucket
parent classes.

The handlers also need to lock/open the engine, and thus Ha_handler
now contains complimentary ha_engine_lock() / _yield() methods. These
do NOT have any propagation handling, but are there for
consistency/readability and for future extensions. Might be a good
idea to make *those* responsible for telling *Bucket* children about
lock changes???

Renamed "iface" to "bucket"; "bucket_bucket" to just "bucket"!

Some notation consistency changes: input parameters that would shadow class 
members (that need to be reached) has _ prefix, like "_mei". Class members 
are ordered (a bit) after "essentialness", and ditto for class constructor 
parameters.
